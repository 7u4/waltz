= Approaches to Platform Flows
David Watkins<david.watkins@db.com>;
Mark Guerriero<mark.guerriero@db.com>;
:toc:

== Overview

* Lineage
* Ownership
** Accountability / Attestation
* ...


== Types of Platforms

* _Infrastructure_ platforms, hold or forward the data to the recipient without altering the data content.
* _Enrichment_ platforms, which may blend data from several sources before it reaches the recipients
* _Multitenancy_ platforms

<<<

== Overview of current model

The diagram below shows a simplified version of the model used by Waltz to represent flows.

_Logical flows_ connect two endpoints, which are typically applications.
The logical flows can be decorated with _data types_ (not shown).

Each logical flow may have _physical flows_ associated with it.
Each physical flows has a _physical specification_ which describes the content of the data.
Physical specifications can be reused across physical flows.


.Current flow model
[graphviz, merged, svg]
----
digraph B {
    app1[label="Source\nApplication", color="green"];
    app2[label="Target\nApplication", color="green"];

    lf1_2[label="App1 &raquo; App2\nLogical Flow", shape=box, color=darkgreen, style=solid];

    pf1[label="0839_LS2_CON.dat\nPhysical Flow", shape=box, style=solid, color=darkblue];
    pf2[label="0840_LS2_CON.dat\nPhysical Flow", shape=box, style=solid, color=darkblue];

    ps[label="XXX_LS2_CON.dat\nPhysical Spec", shape=box, style=dashed, color=blue];

    app1 -> lf1_2 -> app2;

    lf1_2-> pf1;
    lf1_2 -> pf2;

    pf1 -> ps;
    pf2 -> ps;

    {rank = same; app1; app2; lf1_2}
}
----

<<<


== Flow representation

=== Direct routing

This is the way that flows are currently expressed in Waltz.
We do expect each part of the flow to be documented can only see multi-hop flows via other mechanisms such as flow diagrams or by extracting the raw topology information into tools like Solidatus.
footnote:[link to Solidatus, TBC]

.Platforms using existing model
[graphviz, direct, svg]
----
digraph B {
    plat[label="Platform", color="orange"];
    app1[label="App1", color="green"];
    app2[label="App2", color="green"];

    lf1[label="App1 &raquo; Plat\nLogical Flow", shape=box, color=darkgreen, style=solid];
    lf2[label="Plat &raquo; App2\nLogical Flow", shape=box, color=darkgreen, style=solid];

    app1 -> lf1 -> plat -> lf2 -> app2;

    app1 -> app2 [style=dotted]
    {rank = same; app1; app2; lf1; lf2, plat}
}
----

|===
|Pros |Cons

| Closely resembles actual topology
| Lineage is hard, cannot represent that the intended recipient of the flow from App1 is App2.
In Waltz this is mitigated by using flow diagrams to explicitly depict multi-hop lineage.

| Conceptually simple
| -

|===

==== Attestation
In the current model we view the consuming application as being the owner of the flow.
The reasoning behind this is based on a simple belief that the consumer is more likely to be aware of the flow than the producer.

For simple app-to-app flows systems this model works well and attestation is straightforward; the consumer should attest all inbound flows.
This is depicted in the figure below (App C must attest to the accuracy of the flows from A and B).

.Example of attestation scope for simple apps
[graphviz, direct-att-simple, svg]
----
digraph B {
    A[label="App A", color="green"];
    B[label="App B", color="green"];
    C[label="App C"];
    D[label="App C"];

    A->C[color=green];
    B->C[color=green];
    C->D;
}
----

However, when we have aggregation/distribution platforms the attestation burden falls upon the platform.
Often the platform owners are not in a position to be able to accurately perform the required attestation, especially in mulit-tenancy situations.

This is depicted in the following figure, the green flows show a large volume of inbound flows to the platform which may have little knowledge of their contents.

.Direct attestation for platforms
[graphviz, direct-att-complex, svg]
----
digraph B {

    plat[label="Platform\n???", color="orange"];
    app1[label="App1", color="green"];
    app2[label="App2", color="green"];
    app3[label="App3", color="green"];
    app4[label="App4", color="green"];
    app5[label="App5", color="green"];
    appN[label="...", color="green"];
    app6[label="App6"];
    app7[label="App7"];
    app8[label="App8"];
    app9[label="App9"];
    appNN[label="..."];

    app1 -> plat [color="green"];
    app2 -> plat [color="green"];
    app3 -> plat [color="green"];
    app4 -> plat [color="green"];
    app5 -> plat [color="green"];
    appN -> plat [style="dashed"; color="green"];
    plat -> app6 [color="grey"];
    plat -> app7 [color="grey"];
    plat -> app8 [color="grey"];
    plat -> app9 [color="grey"];
    plat -> appNN [style="dashed"; color="grey"];
}
----


<<<



=== 'Via' routing

In this approach the flow of data between `App1` and `App2`


.Platforms using physical routing
[graphviz, via, svg]
----
digraph B {
    app1[label="App1", color="green"];
    app2[label="App2", color="green"];
    plat[label="Platform", color="orange"];

    lf1[label="App1 &raquo; App2\nLogical Flow", shape=box, color=darkgreen, style=solid];

    pf1[label="Physical Flow", shape=box, style=solid, color=darkblue];

    app1 -> lf1 -> app2;

    lf1 -> pf1;

    pf1 -> plat [label="via"];

    {rank = same; app1; app2; lf1}

}
----


|===
|Pros |Cons

| Simplifies basic lineage
| Multi hop _via_ routes difficult to express

| -
| Inconsistency of recording.
If App1 does not know, or particularly care about, App2 (or vice versa)

| Intuitive understanding
| -

|===

<<<


=== 'Ultimate Recipient' routing

A variation of _via routing_ is to store the intended recipient as an optional (list?) attribute on the physical flow.


.Platforms using physical routing
[graphviz, ultimate, svg]
----
digraph B {
    app1[label="App1", color="green"];
    app2[label="App2", color="green"];
    plat[label="Platform", color="orange"];

    lf1[label="App1 &raquo; App2\nLogical Flow", shape=box, color=darkgreen, style=solid];

    pf1[label="Physical Flow", shape=box, style=solid, color=darkblue];

    app1 -> lf1 -> plat;

    lf1 -> pf1;

    pf1 -> app2 [label="ultimate recipient"];

    {rank = same; app1; plat; lf1}
}
----


|===
|Pros |Cons

| Simplifies basic lineage
| Multi-hop _via_ cannot be expressed

| -
| Inconsistency of recording.
If App1 does not know, or particularly care about, App2 (or vice versa)

| Intuitive understanding
| -

| -
| -
|===

<<<

=== Layers

This approach proposes additional layers of flows.  We currently have

* logical
* physical




<<<


== Appendix: Waltz terminology

This section defines what specific terms mean in this document

* *Logical Flow*, abstractly describes all flows between two entities (typically apps)
* *Physical Flow*, a specific instance of a _logical flow_
* *Physical Specification*, details of what is being transferred in a _physical flow_
* *Data Types*, hierarchical structure representing all types of data within the organization
* *Measurable Category*, (aka _Taxonomy_)
* *Measurables*, hierarchical structure representing items in a _measurable category_
* *Rating Scheme / Item*, used to describe the relationship between entities (typically apps) and _measurables_
* *Measurable Rating*, the actual linkage of an entity to a _measurable_ using a _rating scheme item_

